Index: src/com/company/BasicDOD/Simulator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/company/BasicDOD/Simulator.java	(revision 46880b36a9822efde0f5438d356a91e8b85e3540)
+++ src/com/company/BasicDOD/Simulator.java	(date 1531519168760)
@@ -5,24 +5,34 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Random;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
 
 public class Simulator {
 
+    private static final int numThreads = 64;
+    private static final ExecutorService executorService = Executors.newFixedThreadPool(numThreads);
     private static final Random rand = new Random();
     private final ParticleMovementSystem movementSystem;
+    private final int particleCount;
 
-    private List<ParticleData> particles = new ArrayList<>();
+    private List<ParticleData> particles;
 
     Simulator(int particleCount) {
         movementSystem = new ParticleMovementSystem();
-        addParticles(particleCount);
+        this.particleCount = particleCount;
+        particles = new ArrayList<>(this.particleCount);
+        addParticles(this.particleCount);
     }
 
     public void run() {
         long iterCount = 0;
-        float avgDeltaTime = 0.0f;
-        float time = getTime();
-        float freshTime;
+        double avgDeltaTime = 0.0f;
+        double time = getTime();
+        double freshTime;
         while (true) {
 
             simulate();
@@ -38,19 +48,56 @@
     }
 
     private void simulate() {
-        for (int i = 0; i < particles.size(); i++) {
-            // it is faster to update each particle via mutation
-            movementSystem.update(
-                    particles.get(i).position,
-                    particles.get(i).velocity);
+        int chunkSize = (particleCount) / numThreads;
+        List<Callable<Void>> futures = new ArrayList<>();
+
+        for (int i = 0; i < numThreads; i++) {
+            final int start = chunkSize * i;
+            final int end = start + chunkSize - 1;
+            final List<ParticleData> subparticles = particles.subList(start, end);
+
+            final int finalI = i;
+            Callable<Void> runnable = () -> {
+                final int chunkStart = chunkSize * finalI;
+                final int chunkEnd = chunkStart + chunkSize - 1;
+                // System.out.printf("Thread %d: %d -> %d%n", finalI, chunkStart, chunkEnd);
+                for (int j = chunkStart; j < chunkEnd; j++) {
+                    ParticleData particleData = subparticles.get(j);
+                    movementSystem.update(
+                            particleData.position,
+                            particleData.velocity);
+                    // subparticles.set(finalI, movementSystem.updateFunctional(particles.get(finalI).position, particles.get(finalI).velocity));
+                }
+                return null;
+            };
+
+            futures.add(runnable);
+        }
+
+        try {
+            List<Future<Void>> futures1 = executorService.invokeAll(futures);
+            for (Future<Void> voidFuture : futures1) {
+                voidFuture.get();
+            }
+
+        } catch (InterruptedException | ExecutionException ignore) {
+
+        }
+
+        // int size = particles.size();
+        // for (int i = 0; i < size; i++) {
+            // it is faster to update each particle via mutation
+            // movementSystem.update(
+            //         particles.get(i).position,
+            //         particles.get(i).velocity);
 
             // the functional construction leads to a roughly 2x increase in deltaTime
             //particles.set(i, movementSystem.updateFunctional(particles.get(i).position, particles.get(i).velocity));
-        }
+        // }
     }
 
     //region Misc Supporting code
-    private float getAvgDeltaTime(float avgDeltaTime, float time, float freshTime, long iterCount) {
+    private double getAvgDeltaTime(double avgDeltaTime, double time, double freshTime, long iterCount) {
         if (avgDeltaTime > 0.001f) {
             return (((iterCount-1)*avgDeltaTime ) + (freshTime - time)) / iterCount;
         } else {
@@ -58,8 +105,8 @@
         }
     }
 
-    private float getTime() {
-        return System.nanoTime() / 1000000f;
+    private double getTime() {
+        return System.nanoTime() / 1_000_000d;
     }
 
     private void addParticles(int count) {
Index: src/com/company/BasicDOD/BasicDODDemo.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/company/BasicDOD/BasicDODDemo.java	(revision 46880b36a9822efde0f5438d356a91e8b85e3540)
+++ src/com/company/BasicDOD/BasicDODDemo.java	(date 1531519449763)
@@ -2,7 +2,7 @@
 
 public class BasicDODDemo {
 
-    private static final int count = 1 * 1000000;
+    private static final int count = 1_048_576;
 
     public static void main(String[] args) {
         new Simulator(count).run();
